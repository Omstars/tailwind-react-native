{"version":3,"file":"tailwind-react-native.modern.js","sources":["../../src/style.js","../../src/transition.js","../../src/create.js","../../src/variant.js","../../src/interpolate.js","../../index.js"],"sourcesContent":["import { Platform } from \"react-native\";\n\nconst transformProps = [\"translate\", \"rotate\", \"scale\", \"skew\"];\n\nfunction createStyleFn(styleMap) {\n  const memo = {};\n\n  return function getStylesForClassnames(classNames = \"\") {\n    if (memo[classNames]) {\n      return memo[classNames];\n    }\n\n    const assembledStyles = {};\n\n    let transforms = [];\n\n    for (let className of classNames.split(\" \")) {\n      if (!className) {\n        continue;\n      }\n\n      let style = styleMap[className];\n\n      if (!style) {\n        continue;\n      }\n\n      if (transformProps.filter((t) => className.includes(t)).length > 0) {\n        transforms.push(style);\n        continue;\n      }\n\n      const platformStyle = Platform.select(style);\n      if (platformStyle) {\n        style = platformStyle;\n      }\n\n      Object.assign(assembledStyles, style);\n    }\n\n    if (transforms.length > 0) {\n      Object.assign(assembledStyles, { transform: transforms });\n    }\n\n    memo[classNames] = assembledStyles;\n    return assembledStyles;\n  };\n}\n\nexport default createStyleFn;\n","import React from \"react\";\nimport { Animated } from \"react-native\";\nimport interpolateStyles from \"./interpolate\";\n\nconst defaultAnimatedConfig = {\n  method: Animated.spring,\n  useNativeDriver: true,\n};\n\nfunction createTransitionFn(variantFn) {\n  // improvements:\n  // we can map over the classNames object and get the interpolations matrix all at once?\n  // we can hold onto the animatedValue over rerenders and transition to new styles smoothlier\n  return function useTransition(\n    classNames = \"\",\n    variantValue,\n    animatedConfig = {}\n  ) {\n    const previousVariant = usePrevious(variantValue);\n\n    const currentStyle = variantFn(classNames, variantValue);\n\n    if (!previousVariant) {\n      return currentStyle;\n    }\n\n    let previousStyle = variantFn(classNames, previousVariant);\n\n    const animatedValue = new Animated.Value(1);\n\n    const animatedStyle = interpolateStyles(\n      animatedValue,\n      currentStyle,\n      previousStyle\n    );\n\n    const { method, ...rest } = {\n      ...defaultAnimatedConfig,\n      ...animatedConfig,\n    };\n\n    method(animatedValue, {\n      toValue: 0,\n      ...rest,\n    }).start();\n\n    return animatedStyle;\n  };\n}\n\nexport default createTransitionFn;\n\nfunction usePrevious(value) {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  const ref = React.useRef();\n\n  // Store current value in ref\n  React.useEffect(() => {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n\n  // Return previous value (happens before update in useEffect above)\n  return ref.current;\n}\n","import styles from \"../styles.json\";\nimport createStyleFn from \"./style\";\nimport createVariantFn from \"./variant\";\nimport createTransitionFn from \"./transition\";\n\nfunction create(styleMap = styles) {\n  const style = createStyleFn(styleMap);\n  const variant = createVariantFn(style);\n  const useTransition = createTransitionFn(variant);\n\n  return {\n    style,\n    variant,\n    useTransition,\n  };\n}\n\nexport default create;\n","function createVariantFn(styleFn) {\n  const memo = {};\n\n  return function getStylesForVariant(classNames = \"\", variantValue) {\n    if (typeof classNames === \"object\") {\n      return styleFn(classNames[variantValue]);\n    }\n\n    let key = `${classNames}`;\n\n    if (memo[key]) {\n      return styleFn(memo[key][variantValue]);\n    }\n\n    memo[key] = {};\n\n    let stylesByVariant = {};\n\n    for (let cn of classNames.split(\" \")) {\n      if (!cn) {\n        continue;\n      }\n\n      const [variant, className] = cn.split(\":\");\n\n      if (!stylesByVariant[variant]) {\n        stylesByVariant[variant] = [];\n      }\n\n      if (!variant || !className) {\n        continue;\n      }\n\n      stylesByVariant[variant] += `${className} `;\n    } \n\n    Object.keys(stylesByVariant).forEach((variant) => {\n      console.log({ variant });\n    });\n\n    memo[key] = stylesByVariant;\n    console.log({ stylesByVariant });\n    return styleFn(stylesByVariant[variantValue]);\n  };\n}\n\nexport default createVariantFn;\n","function interpolateStyles(value, ...styles) {\n  const interpolations = getInterpolationsForStyles(...styles);\n  const interpolatedStyle = applyAnimatedValueToInterpolations(value, interpolations);\n  return interpolatedStyle;\n}\n\nfunction getInterpolationsForStyles(...styles) {\n  const output = {};\n\n  if (styles.length === 0) {\n    return {};\n  }\n\n  if (styles.length === 1) {\n    return styles;\n  }\n\n  styles.forEach((style, index) => {\n    structureStylesToInterpolation(output, style, index);\n  });\n\n  // transform back to array\n  if (output.transform) {\n    output.transform = Object.keys(output.transform).map((key) => {\n      return {\n        [key]: output.transform[key],\n      };\n    });\n  }\n\n  return output;\n}\n\nfunction structureStylesToInterpolation(output = {}, style = {}, index) {\n  style.transform = style.transform || [];\n\n  const styleKeys = Object.keys(style);\n\n  styleKeys.forEach((styleProp) => {\n    if (style[styleProp] !== undefined && styleProp !== \"transform\") {\n      if (!output[styleProp]) {\n        output[styleProp] = {\n          inputRange: [],\n          outputRange: [],\n        };\n      }\n\n      output[styleProp].inputRange.push(index);\n      output[styleProp].outputRange.push(style[styleProp]);\n    }\n  });\n\n  if (style.transform.length) {\n    style.transform.forEach((transformation) => {\n      if (!output.transform) {\n        // use an obj and convert to array after\n        output.transform = {};\n      }\n\n      const [propertyName] = Object.keys(transformation);\n      if (!output.transform[propertyName]) {\n        output.transform[propertyName] = {\n          inputRange: [],\n          outputRange: [],\n        };\n      }\n\n      output.transform[propertyName].inputRange.push(index);\n      output.transform[propertyName].outputRange.push(\n        transformation[propertyName]\n      );\n    });\n  }\n}\n\nfunction applyAnimatedValueToInterpolations(value, styles) {\n  const assembledStyles = {};\n\n  styles.transform = styles.transform || [];\n\n  styles.transform.forEach((transformation) => {\n    const [transformProperty] = Object.keys(transformation);\n    const interpolation = transformation[transformProperty];\n\n    const interpolatedStyle = value.interpolate(interpolation);\n\n    if (!assembledStyles.transform) {\n      assembledStyles.transform = [];\n    }\n\n    assembledStyles.transform.push({ [transformProperty]: interpolatedStyle });\n  });\n\n  Object.keys(styles).forEach((key) => {\n    if (styles[key] && key !== \"transform\") {\n      assembledStyles[key] = value.interpolate(styles[key]);\n    }\n  });\n\n  return assembledStyles;\n}\n\nexport default interpolateStyles;\n","import create from \"./src/create\";\nimport styles from \"./styles.json\";\n\nconst { variant, style, useTransition } = create(styles);\n\nexport { style, useTransition, create, variant };\n"],"names":["transformProps","defaultAnimatedConfig","method","Animated","spring","useNativeDriver","create","styleMap","styles","style","memo","classNames","assembledStyles","transforms","className","split","filter","t","includes","length","push","platformStyle","Platform","select","Object","assign","transform","createStyleFn","variant","styleFn","variantValue","key","stylesByVariant","cn","keys","forEach","console","log","createVariantFn","useTransition","variantFn","animatedConfig","previousVariant","value","ref","React","useRef","useEffect","current","usePrevious","currentStyle","previousStyle","animatedValue","Value","animatedStyle","transformation","transformProperty","interpolatedStyle","interpolate","[object Object]","applyAnimatedValueToInterpolations","output","index","styleProp","undefined","inputRange","outputRange","propertyName","structureStylesToInterpolation","map","getInterpolationsForStyles","interpolateStyles","toValue","start"],"mappings":"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"}