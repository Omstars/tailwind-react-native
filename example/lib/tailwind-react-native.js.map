{"version":3,"file":"tailwind-react-native.js","sources":["../../src/style.js","../../src/interpolate.js","../../src/transition.js","../../src/create.js","../../src/variant.js","../../index.js"],"sourcesContent":["import { Platform } from \"react-native\";\n\nconst transformProps = [\"translate\", \"rotate\", \"scale\", \"skew\"];\n\nfunction createStyleFn(styleMap) {\n  const memo = {};\n\n  return function getStylesForClassnames(classNames = \"\") {\n    if (memo[classNames]) {\n      return memo[classNames];\n    }\n\n    const assembledStyles = {};\n\n    let transforms = [];\n\n    for (let className of classNames.split(\" \")) {\n      if (!className) {\n        continue;\n      }\n\n      let style = styleMap[className];\n\n      if (!style) {\n        continue;\n      }\n\n      if (transformProps.filter((t) => className.includes(t)).length > 0) {\n        transforms.push(style);\n        continue;\n      }\n\n      const platformStyle = Platform.select(style);\n      if (platformStyle) {\n        style = platformStyle;\n      }\n\n      Object.assign(assembledStyles, style);\n    }\n\n    if (transforms.length > 0) {\n      Object.assign(assembledStyles, { transform: transforms });\n    }\n\n    memo[classNames] = assembledStyles;\n    return assembledStyles;\n  };\n}\n\nexport default createStyleFn;\n","function interpolateStyles(value, ...styles) {\n  const interpolations = getInterpolationsForStyles(...styles);\n  const interpolatedStyle = applyAnimatedValueToInterpolations(value, interpolations);\n  return interpolatedStyle;\n}\n\nfunction getInterpolationsForStyles(...styles) {\n  const output = {};\n\n  if (styles.length === 0) {\n    return {};\n  }\n\n  if (styles.length === 1) {\n    return styles;\n  }\n\n  styles.forEach((style, index) => {\n    structureStylesToInterpolation(output, style, index);\n  });\n\n  // transform back to array\n  if (output.transform) {\n    output.transform = Object.keys(output.transform).map((key) => {\n      return {\n        [key]: output.transform[key],\n      };\n    });\n  }\n\n  return output;\n}\n\nfunction structureStylesToInterpolation(output = {}, style = {}, index) {\n  style.transform = style.transform || [];\n\n  const styleKeys = Object.keys(style);\n\n  styleKeys.forEach((styleProp) => {\n    if (style[styleProp] !== undefined && styleProp !== \"transform\") {\n      if (!output[styleProp]) {\n        output[styleProp] = {\n          inputRange: [],\n          outputRange: [],\n        };\n      }\n\n      output[styleProp].inputRange.push(index);\n      output[styleProp].outputRange.push(style[styleProp]);\n    }\n  });\n\n  if (style.transform.length) {\n    style.transform.forEach((transformation) => {\n      if (!output.transform) {\n        // use an obj and convert to array after\n        output.transform = {};\n      }\n\n      const [propertyName] = Object.keys(transformation);\n      if (!output.transform[propertyName]) {\n        output.transform[propertyName] = {\n          inputRange: [],\n          outputRange: [],\n        };\n      }\n\n      output.transform[propertyName].inputRange.push(index);\n      output.transform[propertyName].outputRange.push(\n        transformation[propertyName]\n      );\n    });\n  }\n}\n\nfunction applyAnimatedValueToInterpolations(value, styles) {\n  const assembledStyles = {};\n\n  styles.transform = styles.transform || [];\n\n  styles.transform.forEach((transformation) => {\n    const [transformProperty] = Object.keys(transformation);\n    const interpolation = transformation[transformProperty];\n\n    const interpolatedStyle = value.interpolate(interpolation);\n\n    if (!assembledStyles.transform) {\n      assembledStyles.transform = [];\n    }\n\n    assembledStyles.transform.push({ [transformProperty]: interpolatedStyle });\n  });\n\n  Object.keys(styles).forEach((key) => {\n    if (styles[key] && key !== \"transform\") {\n      assembledStyles[key] = value.interpolate(styles[key]);\n    }\n  });\n\n  return assembledStyles;\n}\n\nexport default interpolateStyles;\n","import React from \"react\";\nimport { Animated } from \"react-native\";\nimport interpolateStyles from \"./interpolate\";\n\nconst defaultAnimatedConfig = {\n  method: Animated.spring,\n  useNativeDriver: true,\n};\n\nfunction createTransitionFn(variantFn) {\n  // improvements:\n  // we can map over the classNames object and get the interpolations matrix all at once?\n  // we can hold onto the animatedValue over rerenders and transition to new styles smoothlier\n  return function useTransition(\n    classNames = \"\",\n    variantValue,\n    animatedConfig = {}\n  ) {\n    const previousVariant = usePrevious(variantValue);\n\n    const currentStyle = variantFn(classNames, variantValue);\n\n    if (!previousVariant) {\n      return currentStyle;\n    }\n\n    let previousStyle = variantFn(classNames, previousVariant);\n\n    const animatedValue = new Animated.Value(1);\n\n    const animatedStyle = interpolateStyles(\n      animatedValue,\n      currentStyle,\n      previousStyle\n    );\n\n    const { method, ...rest } = {\n      ...defaultAnimatedConfig,\n      ...animatedConfig,\n    };\n\n    method(animatedValue, {\n      toValue: 0,\n      ...rest,\n    }).start();\n\n    return animatedStyle;\n  };\n}\n\nexport default createTransitionFn;\n\nfunction usePrevious(value) {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  const ref = React.useRef();\n\n  // Store current value in ref\n  React.useEffect(() => {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n\n  // Return previous value (happens before update in useEffect above)\n  return ref.current;\n}\n","import styles from \"../styles.json\";\nimport createStyleFn from \"./style\";\nimport createVariantFn from \"./variant\";\nimport createTransitionFn from \"./transition\";\n\nfunction create(styleMap = styles) {\n  const style = createStyleFn(styleMap);\n  const variant = createVariantFn(style);\n  const useTransition = createTransitionFn(variant);\n\n  return {\n    style,\n    variant,\n    useTransition,\n  };\n}\n\nexport default create;\n","function createVariantFn(styleFn) {\n  const memo = {};\n\n  return function getStylesForVariant(classNames = \"\", variantValue) {\n    if (typeof classNames === \"object\") {\n      return styleFn(classNames[variantValue]);\n    }\n\n    let key = `${classNames}`;\n\n    if (memo[key]) {\n      return styleFn(memo[key][variantValue]);\n    }\n\n    memo[key] = {};\n\n    let stylesByVariant = {};\n\n    for (let cn of classNames.split(\" \")) {\n      if (!cn) {\n        continue;\n      }\n\n      const [variant, className] = cn.split(\":\");\n\n      if (!stylesByVariant[variant]) {\n        stylesByVariant[variant] = [];\n      }\n\n      if (!variant || !className) {\n        continue;\n      }\n\n      stylesByVariant[variant] += `${className} `;\n    } \n\n    Object.keys(stylesByVariant).forEach((variant) => {\n      console.log({ variant });\n    });\n\n    memo[key] = stylesByVariant;\n    console.log({ stylesByVariant });\n    return styleFn(stylesByVariant[variantValue]);\n  };\n}\n\nexport default createVariantFn;\n","import create from \"./src/create\";\nimport styles from \"./styles.json\";\n\nconst { variant, style, useTransition } = create(styles);\n\nexport { style, useTransition, create, variant };\n"],"names":["transformProps","getInterpolationsForStyles","styles","output","length","forEach","style","index","structureStylesToInterpolation","transform","Object","keys","map","key","styleProp","undefined","inputRange","outputRange","push","transformation","propertyName","applyAnimatedValueToInterpolations","value","assembledStyles","transformProperty","interpolatedStyle","interpolate","defaultAnimatedConfig","method","Animated","spring","useNativeDriver","create","styleMap","styleFn","memo","variantFn","classNames","transforms","className","filter","t","includes","platformStyle","Platform","select","assign","split","createStyleFn","variant","variantValue","stylesByVariant","cn","console","log","useTransition","animatedConfig","ref","previousVariant","React","useRef","useEffect","current","currentStyle","previousStyle","animatedValue","Value","animatedStyle","interpolations","interpolateStyles","toValue","start"],"mappings":"ikuGAEA,IAAMA,EAAiB,CAAC,YAAa,SAAU,QAAS,QCIxD,SAASC,QAA8BC,2BAC/BC,EAAS,GAEf,OAAsB,IAAlBD,EAAOE,OACF,GAGa,IAAlBF,EAAOE,OACFF,GAGTA,EAAOG,QAAQ,SAACC,EAAOC,GACrBC,EAA+BL,EAAQG,EAAOC,KAI5CJ,EAAOM,YACTN,EAAOM,UAAYC,OAAOC,KAAKR,EAAOM,WAAWG,IAAI,SAACC,SACpD,aACGA,GAAMV,EAAOM,UAAUI,QAKvBV,GAGT,SAASK,EAA+BL,EAAaG,EAAYC,YAAzBJ,IAAAA,EAAS,aAAIG,IAAAA,EAAQ,IAC3DA,EAAMG,UAAYH,EAAMG,WAAa,GAEnBC,OAAOC,KAAKL,GAEpBD,QAAQ,SAACS,QACQC,IAArBT,EAAMQ,IAA0C,cAAdA,IAC/BX,EAAOW,KACVX,EAAOW,GAAa,CAClBE,WAAY,GACZC,YAAa,KAIjBd,EAAOW,GAAWE,WAAWE,KAAKX,GAClCJ,EAAOW,GAAWG,YAAYC,KAAKZ,EAAMQ,OAIzCR,EAAMG,UAAUL,QAClBE,EAAMG,UAAUJ,QAAQ,SAACc,GAClBhB,EAAOM,YAEVN,EAAOM,UAAY,IAHqB,IAMnCW,EAAgBV,OAAOC,KAAKQ,MAC9BhB,EAAOM,UAAUW,KACpBjB,EAAOM,UAAUW,GAAgB,CAC/BJ,WAAY,GACZC,YAAa,KAIjBd,EAAOM,UAAUW,GAAcJ,WAAWE,KAAKX,GAC/CJ,EAAOM,UAAUW,GAAcH,YAAYC,KACzCC,EAAeC,MAMvB,SAASC,EAAmCC,EAAOpB,GACjD,IAAMqB,EAAkB,GAuBxB,OArBArB,EAAOO,UAAYP,EAAOO,WAAa,GAEvCP,EAAOO,UAAUJ,QAAQ,SAACc,SACjBK,EAAqBd,OAAOC,KAAKQ,MAGlCM,EAAoBH,EAAMI,YAFVP,EAAeK,IAIhCD,EAAgBd,YACnBc,EAAgBd,UAAY,IAG9Bc,EAAgBd,UAAUS,aAAQM,GAAoBC,QAGxDf,OAAOC,KAAKT,GAAQG,QAAQ,SAACQ,GACvBX,EAAOW,IAAgB,cAARA,IACjBU,EAAgBV,GAAOS,EAAMI,YAAYxB,EAAOW,OAI7CU,EC/FT,IAAMI,EAAwB,CAC5BC,OAAQC,WAASC,OACjBC,iBAAiB,GCDnB,SAASC,EAAOC,YAAAA,IAAAA,EAAW/B,GACzB,ICNuBgC,EACjBC,EFQoBC,ECHpB9B,EHFR,SAAuB2B,GACrB,IAAME,EAAO,GAEb,gBAAuCE,GACrC,YADqCA,IAAAA,EAAa,IAC9CF,EAAKE,GACP,OAAOF,EAAKE,GAOd,IAJA,MAAMd,EAAkB,GAEpBe,EAAa,oBAERC,UACP,IAAKA,EACH,iBAGF,IAAIjC,EAAQ2B,EAASM,GAErB,IAAKjC,EACH,iBAGF,GAAIN,EAAewC,OAAO,SAACC,UAAMF,EAAUG,SAASD,KAAIrC,OAAS,EAE/D,OADAkC,EAAWpB,KAAKZ,cAIlB,IAAMqC,EAAgBC,WAASC,OAAOvC,GAClCqC,IACFrC,EAAQqC,GAGVjC,OAAOoC,OAAOvB,EAAiBjB,QArBX+B,EAAWU,MAAM,yBA6BvC,OALIT,EAAWlC,OAAS,GACtBM,OAAOoC,OAAOvB,EAAiB,CAAEd,UAAW6B,IAG9CH,EAAKE,GAAcd,EACZA,GGvCKyB,CAAcf,GACtBgB,GCPiBf,EDOS5B,ECN1B6B,EAAO,YAEuBE,EAAiBa,GACnD,YADkCb,IAAAA,EAAa,IACrB,iBAAfA,EACT,OAAOH,EAAQG,EAAWa,IAG5B,IAAIrC,KAASwB,EAEb,GAAIF,EAAKtB,GACP,OAAOqB,EAAQC,EAAKtB,GAAKqC,IAG3Bf,EAAKtB,GAAO,GAIZ,IAFA,MAAIsC,EAAkB,OAEPd,EAAWU,MAAM,qBAAM,KAA7BK,UACP,GAAKA,EAAL,CADoC,MAKPA,EAAGL,MAAM,KAA/BE,OAASV,OAEXY,EAAgBF,KACnBE,EAAgBF,GAAW,IAGxBA,GAAYV,IAIjBY,EAAgBF,IAAeV,QASjC,OANA7B,OAAOC,KAAKwC,GAAiB9C,QAAQ,SAAC4C,GACpCI,QAAQC,IAAI,CAAEL,QAAAA,MAGhBd,EAAKtB,GAAOsC,EACZE,QAAQC,IAAI,CAAEH,gBAAAA,IACPjB,EAAQiB,EAAgBD,MDhCjC,MAAO,CACL5C,MAAAA,EACA2C,QAAAA,EACAM,eDJwBnB,ECDea,WDMvCZ,EACAa,EACAM,YAFAnB,IAAAA,EAAa,aAEbmB,IAAAA,EAAiB,IAEjB,IAkCiBlC,EAGbmC,EArCEC,GAkCWpC,EAlCmB4B,EAqChCO,EAAME,UAAMC,SAGlBD,UAAME,UAAU,WACdJ,EAAIK,QAAUxC,GACb,CAACA,IAGGmC,EAAIK,SA3CHC,EAAe3B,EAAUC,EAAYa,GAE3C,IAAKQ,EACH,OAAOK,EAGT,IAAIC,EAAgB5B,EAAUC,EAAYqB,GAEpCO,EAAgB,IAAIpC,WAASqC,MAAM,GAEnCC,ED9BV,SAA2B7C,GACzB,IAAM8C,EAAiBnE,2CAEvB,OAD0BoB,EAAmCC,EAAO8C,GC4B5CC,CACpBJ,EACAF,EACAC,UAIGrC,EACA6B,GAQL,OALA5B,IALQA,QAKDqC,KACLK,QAAS,sJAERC,QAEIJ,WG3C+BnC,EAAO9B,GAAzC+C,IAAAA,QAAS3C,IAAAA,MAAOiD,IAAAA"}